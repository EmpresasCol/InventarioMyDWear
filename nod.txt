// ==================== PACKAGE.JSON ====================
{
  "name": "inventory-backend",
  "version": "1.0.0",
  "description": "Sistema de inventario - Backend",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mysql2": "^3.6.0",
    "cors": "^2.8.5",
    "multer": "^1.4.5-lts.1",
    "cloudinary": "^1.40.0",
    "dotenv": "^16.3.1",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "express-validator": "^7.0.1",
    "helmet": "^7.0.0",
    "express-rate-limit": "^6.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}

// ==================== SERVER.JS ====================
const express = require('express');
const mysql = require('mysql2/promise');
const cors = require('cors');
const multer = require('multer');
const cloudinary = require('cloudinary').v2;
const path = require('path');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Configuración de Cloudinary para imágenes
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

// Middleware
app.use(cors({
  origin: ['http://localhost:3000', 'https://tu-usuario.github.io'],
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Configuración de MySQL
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME || 'inventory_db',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  timezone: '+00:00'
};

let pool;

// Inicializar conexión a la base de datos
async function initDB() {
  try {
    pool = mysql.createPool(dbConfig);
    
    // Crear base de datos si no existe
    await pool.execute(`CREATE DATABASE IF NOT EXISTS ${dbConfig.database}`);
    await pool.execute(`USE ${dbConfig.database}`);
    
    // Crear tablas
    await createTables();
    console.log('✅ Base de datos inicializada correctamente');
  } catch (error) {
    console.error('❌ Error al inicializar la base de datos:', error);
    process.exit(1);
  }
}

// Crear tablas
async function createTables() {
  // Tabla de productos
  const createProductsTable = `
    CREATE TABLE IF NOT EXISTS products (
      id INT AUTO_INCREMENT PRIMARY KEY,
      type ENUM('conjunto', 'boxer') NOT NULL,
      size ENUM('XS', 'S', 'M', 'L', 'XL', 'XXL') NOT NULL,
      color VARCHAR(50) NOT NULL,
      quantity INT NOT NULL DEFAULT 0,
      price DECIMAL(10, 2) DEFAULT 0.00,
      brand VARCHAR(50) NULL,
      logo_type ENUM('pequeñas', 'grandes') NULL,
      image_url VARCHAR(500) NULL,
      image_public_id VARCHAR(200) NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
      INDEX idx_type (type),
      INDEX idx_size (size),
      INDEX idx_brand (brand)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
  `;

  // Tabla de movimientos de inventario (historial)
  const createMovementsTable = `
    CREATE TABLE IF NOT EXISTS inventory_movements (
      id INT AUTO_INCREMENT PRIMARY KEY,
      product_id INT NOT NULL,
      movement_type ENUM('entrada', 'salida', 'ajuste') NOT NULL,
      quantity INT NOT NULL,
      previous_quantity INT NOT NULL,
      new_quantity INT NOT NULL,
      reason VARCHAR(255) NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
      INDEX idx_product_id (product_id),
      INDEX idx_movement_type (movement_type),
      INDEX idx_created_at (created_at)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
  `;

  await pool.execute(createProductsTable);
  await pool.execute(createMovementsTable);
}

// Configuración de Multer para subida de archivos
const storage = multer.memoryStorage();
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen'), false);
    }
  }
});

// ==================== RUTAS API ====================

// GET /api/products - Obtener todos los productos
app.get('/api/products', async (req, res) => {
  try {
    const { type, size, brand, search } = req.query;
    let query = 'SELECT * FROM products WHERE 1=1';
    const params = [];

    if (type) {
      query += ' AND type = ?';
      params.push(type);
    }

    if (size) {
      query += ' AND size = ?';
      params.push(size);
    }

    if (brand) {
      query += ' AND brand = ?';
      params.push(brand);
    }

    if (search) {
      query += ' AND (color LIKE ? OR brand LIKE ?)';
      params.push(`%${search}%`, `%${search}%`);
    }

    query += ' ORDER BY created_at DESC';

    const [rows] = await pool.execute(query, params);
    res.json({ success: true, data: rows });
  } catch (error) {
    console.error('Error al obtener productos:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// POST /api/products - Crear nuevo producto
app.post('/api/products', upload.single('image'), async (req, res) => {
  try {
    const { type, size, color, quantity, price, brand, logo_type } = req.body;

    // Validaciones
    if (!type || !size || !color || !quantity) {
      return res.status(400).json({ 
        success: false, 
        message: 'Faltan campos obligatorios' 
      });
    }

    if (type === 'conjunto' && !brand) {
      return res.status(400).json({ 
        success: false, 
        message: 'La marca es obligatoria para conjuntos deportivos' 
      });
    }

    if (type === 'boxer' && !logo_type) {
      return res.status(400).json({ 
        success: false, 
        message: 'El tipo de logo es obligatorio para boxers' 
      });
    }

    let imageUrl = null;
    let imagePublicId = null;

    // Subir imagen a Cloudinary si existe
    if (req.file) {
      try {
        const result = await new Promise((resolve, reject) => {
          cloudinary.uploader.upload_stream(
            {
              resource_type: 'image',
              folder: 'inventory',
              transformation: [
                { width: 500, height: 500, crop: 'fill', quality: 'auto' }
              ]
            },
            (error, result) => {
              if (error) reject(error);
              else resolve(result);
            }
          ).end(req.file.buffer);
        });

        imageUrl = result.secure_url;
        imagePublicId = result.public_id;
      } catch (uploadError) {
        console.error('Error al subir imagen:', uploadError);
        return res.status(500).json({ 
          success: false, 
          message: 'Error al subir la imagen' 
        });
      }
    }

    // Insertar producto en la base de datos
    const insertQuery = `
      INSERT INTO products (type, size, color, quantity, price, brand, logo_type, image_url, image_public_id)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const [result] = await pool.execute(insertQuery, [
      type, size, color, parseInt(quantity), parseFloat(price) || 0,
      brand || null, logo_type || null, imageUrl, imagePublicId
    ]);

    // Registrar movimiento de inventario
    await pool.execute(
      'INSERT INTO inventory_movements (product_id, movement_type, quantity, previous_quantity, new_quantity, reason) VALUES (?, ?, ?, ?, ?, ?)',
      [result.insertId, 'entrada', parseInt(quantity), 0, parseInt(quantity), 'Producto creado']
    );

    res.status(201).json({ 
      success: true, 
      message: 'Producto creado exitosamente',
      data: { id: result.insertId }
    });

  } catch (error) {
    console.error('Error al crear producto:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// PUT /api/products/:id - Actualizar producto
app.put('/api/products/:id', upload.single('image'), async (req, res) => {
  try {
    const productId = req.params.id;
    const { size, color, quantity, price, brand, logo_type } = req.body;

    // Verificar que el producto existe
    const [existingProduct] = await pool.execute(
      'SELECT * FROM products WHERE id = ?', 
      [productId]
    );

    if (existingProduct.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Producto no encontrado' 
      });
    }

    const product = existingProduct[0];
    let imageUrl = product.image_url;
    let imagePublicId = product.image_public_id;

    // Actualizar imagen si se proporciona una nueva
    if (req.file) {
      try {
        // Eliminar imagen anterior de Cloudinary
        if (imagePublicId) {
          await cloudinary.uploader.destroy(imagePublicId);
        }

        // Subir nueva imagen
        const result = await new Promise((resolve, reject) => {
          cloudinary.uploader.upload_stream(
            {
              resource_type: 'image',
              folder: 'inventory',
              transformation: [
                { width: 500, height: 500, crop: 'fill', quality: 'auto' }
              ]
            },
            (error, result) => {
              if (error) reject(error);
              else resolve(result);
            }
          ).end(req.file.buffer);
        });

        imageUrl = result.secure_url;
        imagePublicId = result.public_id;
      } catch (uploadError) {
        console.error('Error al actualizar imagen:', uploadError);
        return res.status(500).json({ 
          success: false, 
          message: 'Error al actualizar la imagen' 
        });
      }
    }

    // Actualizar producto
    const updateQuery = `
      UPDATE products 
      SET size = ?, color = ?, quantity = ?, price = ?, brand = ?, logo_type = ?, 
          image_url = ?, image_public_id = ?, updated_at = CURRENT_TIMESTAMP
      WHERE id = ?
    `;

    await pool.execute(updateQuery, [
      size || product.size,
      color || product.color,
      quantity !== undefined ? parseInt(quantity) : product.quantity,
      price !== undefined ? parseFloat(price) : product.price,
      brand !== undefined ? brand : product.brand,
      logo_type !== undefined ? logo_type : product.logo_type,
      imageUrl,
      imagePublicId,
      productId
    ]);

    // Registrar movimiento si cambió la cantidad
    if (quantity !== undefined && parseInt(quantity) !== product.quantity) {
      const movementType = parseInt(quantity) > product.quantity ? 'entrada' : 'salida';
      const quantityDiff = Math.abs(parseInt(quantity) - product.quantity);
      
      await pool.execute(
        'INSERT INTO inventory_movements (product_id, movement_type, quantity, previous_quantity, new_quantity, reason) VALUES (?, ?, ?, ?, ?, ?)',
        [productId, movementType, quantityDiff, product.quantity, parseInt(quantity), 'Ajuste de inventario']
      );
    }

    res.json({ 
      success: true, 
      message: 'Producto actualizado exitosamente' 
    });

  } catch (error) {
    console.error('Error al actualizar producto:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// DELETE /api/products/:id - Eliminar producto
app.delete('/api/products/:id', async (req, res) => {
  try {
    const productId = req.params.id;

    // Obtener información del producto antes de eliminarlo
    const [product] = await pool.execute(
      'SELECT * FROM products WHERE id = ?', 
      [productId]
    );

    if (product.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Producto no encontrado' 
      });
    }

    // Eliminar imagen de Cloudinary si existe
    if (product[0].image_public_id) {
      try {
        await cloudinary.uploader.destroy(product[0].image_public_id);
      } catch (error) {
        console.error('Error al eliminar imagen de Cloudinary:', error);
      }
    }

    // Eliminar producto (los movimientos se eliminan automáticamente por CASCADE)
    await pool.execute('DELETE FROM products WHERE id = ?', [productId]);

    res.json({ 
      success: true, 
      message: 'Producto eliminado exitosamente' 
    });

  } catch (error) {
    console.error('Error al eliminar producto:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// GET /api/stats - Obtener estadísticas
app.get('/api/stats', async (req, res) => {
  try {
    // Estadísticas generales
    const [totalProducts] = await pool.execute(
      'SELECT SUM(quantity) as total FROM products'
    );

    const [totalValue] = await pool.execute(
      'SELECT SUM(price * quantity) as total FROM products'
    );

    const [conjuntos] = await pool.execute(
      'SELECT SUM(quantity) as total FROM products WHERE type = "conjunto"'
    );

    const [boxers] = await pool.execute(
      'SELECT SUM(quantity) as total FROM products WHERE type = "boxer"'
    );

    // Estadísticas por marca
    const [brandStats] = await pool.execute(
      'SELECT brand, SUM(quantity) as total FROM products WHERE brand IS NOT NULL GROUP BY brand'
    );

    // Estadísticas por talla
    const [sizeStats] = await pool.execute(
      'SELECT size, SUM(quantity) as total FROM products GROUP BY size ORDER BY total DESC'
    );

    // Productos con stock bajo (menos de 5 unidades)
    const [lowStock] = await pool.execute(
      'SELECT * FROM products WHERE quantity < 5 ORDER BY quantity ASC'
    );

    res.json({
      success: true,
      data: {
        totalProducts: totalProducts[0].total || 0,
        totalValue: totalValue[0].total || 0,
        conjuntos: conjuntos[0].total || 0,
        boxers: boxers[0].total || 0,
        brandStats,
        sizeStats,
        lowStock
      }
    });

  } catch (error) {
    console.error('Error al obtener estadísticas:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// GET /api/movements - Obtener historial de movimientos
app.get('/api/movements', async (req, res) => {
  try {
    const { limit = 50, product_id } = req.query;
    
    let query = `
      SELECT m.*, p.type, p.color, p.size, p.brand
      FROM inventory_movements m
      JOIN products p ON m.product_id = p.id
      WHERE 1=1
    `;
    const params = [];

    if (product_id) {
      query += ' AND m.product_id = ?';
      params.push(product_id);
    }

    query += ' ORDER BY m.created_at DESC LIMIT ?';
    params.push(parseInt(limit));

    const [movements] = await pool.execute(query, params);

    res.json({ success: true, data: movements });

  } catch (error) {
    console.error('Error al obtener movimientos:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Ruta para servir archivos estáticos (si necesitas servir el frontend desde el mismo servidor)
app.use(express.static('public'));

// Middleware de manejo de errores
app.use((error, req, res, next) => {
  console.error('Error no manejado:', error);
  
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ 
        success: false, 
        message: 'El archivo es demasiado grande. Máximo 5MB' 
      });
    }
  }

  res.status(500).json({ 
    success: false, 
    message: 'Error interno del servidor' 
  });
});

// Ruta 404
app.use('*', (req, res) => {
  res.status(404).json({ 
    success: false, 
    message: 'Ruta no encontrada' 
  });
});

// Inicializar servidor
async function startServer() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`🚀 Servidor ejecutándose en puerto ${PORT}`);
    console.log(`📡 API disponible en http://localhost:${PORT}/api`);
  });
}

startServer().catch(error => {
  console.error('Error al iniciar el servidor:', error);
  process.exit(1);
});

// Manejo de cierre graceful
process.on('SIGINT', async () => {
  console.log('\n🛑 Cerrando servidor...');
  if (pool) {
    await pool.end();
  }
  process.exit(0);
});